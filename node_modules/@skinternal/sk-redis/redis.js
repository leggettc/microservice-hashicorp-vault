const Redis = require('ioredis'),
  {logger} = require('@skinternal/sk-logger');

const events = require('events');
const transactionIdEventEmitterMap = {};
const util = require('util');
const eventEmitter = events.EventEmitter;
const get = require('lodash.get');
let timeout = 15000;

function prepareSingleConfig(redisUrl) {
  var idx = redisUrl.indexOf(':');
  if (idx > -1) {
    return {
      port: parseInt(redisUrl.substring(idx + 1), 10),
      host: redisUrl.substring(0, idx)
    };
  }
  return {
    port: 6379,
    host: redisUrl
  };
}

function prepareConfig(redisClusterUrl) {
  const redisOptions = redisClusterUrl.split(',');
  return redisOptions.map(option => prepareSingleConfig(option));
}

function newClient() {
  const retryStrategy = (times) => Math.min(times * 50, 2000);
  var client,
    hostDescription;

  if (global.secrets.redis.useUrl) {
    logger.info(`Redis: using useUrl`)
    if(!global.secrets.redis.urlPath) {
      throw {message:"Could not retrieve Redis url Path"}
    }
    const redisUrl = get(global.partnerSecrets?global.partnerSecrets:process.env,global.secrets.redis.urlPath, '');
    client = new Redis(redisUrl);
    hostDescription = '******'
  } else if (global.secrets.redis.useUrlAsIs) {
    logger.info(`Redis: using useUrlAsIs`)
    if(!global.secrets.redis.url) {
      throw {message:"Could not retrieve Redis url"}
    }

    if(global.secrets.redis.clusterMode) {
      client = new Redis.Cluster([{host: global.secrets.redis.host,port:global.secrets.redis.port}],{
        dnsLookup: (address, callback) => callback(null, address),
        slotsRefreshTimeout: 5000,
        redisOptions: {
          password: global.secrets.redis.password,
          tls: true
          }
      });
    }else {
      client = new Redis(global.secrets.redis.url);
    }

    hostDescription = '******'
  } else if (global.secrets.redis.useTls) {
    logger.info(`Redis: using useTls`)
    if(!(global.secrets.redis.hostPath && global.secrets.redis.portPath && global.secrets.redis.passwordPath )) {
      throw {message:"Could not retrieve host, port and password path for Redis"}
    }
    const hostname = get(global.partnerSecrets?global.partnerSecrets:process.env,global.secrets.redis.hostPath, '');
    const port = get(global.partnerSecrets?global.partnerSecrets:process.env,global.secrets.redis.portPath, '');
    const password = get(global.partnerSecrets?global.partnerSecrets:process.env,global.secrets.redis.passwordPath, '');
    const url =  `rediss://:${password}@${hostname}:${port}`;
    hostDescription = hostname
    logger.info(`Redis: using useTls ${hostname}, ${port}`)

    client = new Redis(url);
  } else if (global.secrets.redis.clusterUrl) {
    const redisHosts = prepareConfig(global.secrets.redis.clusterUrl);
    hostDescription = redisHosts.map(option => option.host).join(', ');
    client = new Redis.Cluster(redisHosts, {
      clusterRetryStrategy: retryStrategy
    });
  } else {
    var {
      host,
      port
    } = prepareSingleConfig(global.secrets.redis.url);
    hostDescription = host;
    client = new Redis({
      port,
      host,
      retryStrategy
    });
  }
  client.on('error', (err) => {
    logger.error('Cannot connect to redis host, automatically retrying. (' + err + ')');
  });

  client.on('connect', () => {
    logger.info(`Successfully connected to redis ${hostDescription}`);
  });
  return client;
}


const localClient = newClient();
const subClient = newClient();
const blockingClient = newClient();


const RedisConnector = function (opts) {
  var self = this;
  if (!(this instanceof RedisConnector)) return new RedisConnector(opts);

  if (!opts.identity) throw new Error('No identity provided in RedisConnector');

  if(opts.synchronous){
    this.synchronous = true
  }

  if(opts.queuePacket && opts.queueConcurrency >= 2){
    this.concurrency = opts.queueConcurrency
  }

  if (opts.timeout) timeout = opts.timeout;

  if(typeof opts.receiveEventsFlag === 'boolean'){
    this.receiveEventsFlag = opts.receiveEventsFlag
  }else {
    this.receiveEventsFlag = true
  }
  this.client = newClient();

  subClient.subscribe(opts.identity);
  subClient.on('message', processAsyncResponseMessage);

  if(opts.originalIdentity){
    subClient.psubscribe(`command_${opts.originalIdentity}*`);
  }else {
    subClient.psubscribe('command*');
  }
  subClient.on('pmessage', processCommand);

  logger.debug('Listening to redis list ' + opts.identity);

  const processPacket = (packet) => {
    if (packet) {
      if (packet.protocol === 'command' && packet.payload && packet.payload.command === 'requestToListenToList' && global.startingTid != packet.payload.tid) {
        console.log('brpopped command requestToListenToList')
        processCommand(null, 'command_' + opts.identity, JSON.stringify(packet.payload))
        return
      }
      let now = new Date().getTime();
      const diff = now - packet.timestamp;
      logger.debug(`Emitting message with transactionId ${packet.tid} sent ${diff}ms ago.`);
      self.emit('message', packet, (err, res) => {
        if (err || res) {
          now = new Date().getTime();
          //TODO: Customize this value as well
          if (now - packet.timestamp > timeout) {
            logger.debug(`Packet was sent more than ${timeout}ms ago, not sending response.`);
          } else {
            if (packet.respondTo) {
              if (packet.respondTo.publish) {
                self.client.publish(packet.respondTo.to, JSON.stringify({
                  to: packet.respondTo.to,
                  from: packet.to,
                  timestamp: new Date().getTime(),
                  originalTimestamp: packet.timestamp,
                  protocol: `${packet.protocol}-resp`,
                  payload: {
                    err,
                    res
                  },
                  tid: packet.respondTo.tid
                }));
              } else {
                let newPacket
                if (err) {
                  newPacket = {
                    to: packet.respondTo.to,
                    from: packet.from,
                    timestamp: new Date().getTime(),
                    originalTimestamp: packet.timestamp,
                    protocol: 'trigger',
                  }

                  if (err.output) { //when a connector has an error, the developer can set parameters - output - which can be used in the flow
                    newPacket.payload = {
                      ...packet.payload,
                      error: err,
                      output: err.output ? err.output : null,
                      success: false
                    }
                    delete newPacket.payload.error.output
                  } else {
                    newPacket.payload = {...packet.payload, error: err, success: false}
                  }

                } else {
                  newPacket = {
                    to: packet.respondTo.to,
                    from: packet.from,
                    timestamp: new Date().getTime(),
                    originalTimestamp: packet.timestamp,
                    protocol: 'trigger',
                    payload: {...packet.payload, ...res}
                  }
                }
                self.client.lpush(packet.respondTo.to, JSON.stringify(newPacket))
              }
            } else if (packet.tid) {
              self.client.publish(packet.from, JSON.stringify({
                to: packet.from,
                from: packet.to,
                timestamp: new Date().getTime(),
                originalTimestamp: packet.timestamp,
                protocol: `${packet.protocol}-resp`,
                payload: {
                  err,
                  res
                },
                tid: packet.tid
              }));
            }
          }
        }
        if (this.synchronous && this.receiveEventsFlag) {
          brPop();
        }
      });
    }
    if (!this.synchronous && this.receiveEventsFlag) {
      brPop();
    }
  }

  const processPacketSynchronous = (packet) =>{

    return new Promise((resolve,reject) => {
      if (!packet) {
        return resolve()
      }
      if (packet.protocol === 'command' && packet.payload && packet.payload.command === 'requestToListenToList' && global.startingTid != packet.payload.tid) {
        console.log('brpopped command requestToListenToList')
        processCommand(null, 'command_' + opts.identity, JSON.stringify(packet.payload))
        return resolve()
      }
      let now = new Date().getTime();
      const diff = now - packet.timestamp;
      logger.debug(`Emitting message with transactionId ${packet.tid} sent ${diff}ms ago.`);
      self.emit('message', packet, (err, res) => {
        if (err || res) {
          now = new Date().getTime();
          //TODO: Customize this value as well
          if (now - packet.timestamp > timeout) {
            logger.debug(`Packet was sent more than ${timeout}ms ago, not sending response.`);
          } else {
            if (packet.respondTo) {
              if (packet.respondTo.publish) {
                self.client.publish(packet.respondTo.to, JSON.stringify({
                  to: packet.respondTo.to,
                  from: packet.to,
                  timestamp: new Date().getTime(),
                  originalTimestamp: packet.timestamp,
                  protocol: `${packet.protocol}-resp`,
                  payload: {
                    err,
                    res
                  },
                  tid: packet.respondTo.tid
                }));
              } else {
                let newPacket
                if (err) {
                  newPacket = {
                    to: packet.respondTo.to,
                    from: packet.from,
                    timestamp: new Date().getTime(),
                    originalTimestamp: packet.timestamp,
                    protocol: 'trigger',
                  }

                  if (err.output) { //when a connector has an error, the developer can set parameters - output - which can be used in the flow
                    newPacket.payload = {
                      ...packet.payload,
                      error: err,
                      output: err.output ? err.output : null,
                      success: false
                    }
                    delete newPacket.payload.error.output
                  } else {
                    newPacket.payload = {...packet.payload, error: err, success: false}
                  }

                } else {
                  newPacket = {
                    to: packet.respondTo.to,
                    from: packet.from,
                    timestamp: new Date().getTime(),
                    originalTimestamp: packet.timestamp,
                    protocol: 'trigger',
                    payload: {...packet.payload, ...res}
                  }
                }
                self.client.lpush(packet.respondTo.to, JSON.stringify(newPacket))
              }
            } else if (packet.tid) {
              self.client.publish(packet.from, JSON.stringify({
                to: packet.from,
                from: packet.to,
                timestamp: new Date().getTime(),
                originalTimestamp: packet.timestamp,
                protocol: `${packet.protocol}-resp`,
                payload: {
                  err,
                  res
                },
                tid: packet.tid
              }));
            }
          }
        }
        resolve()
      });
    });
  }
  const brPop = () => {

    if(!this.concurrency){
      blockingClient.brpop(opts.identity, 0, (err, data) => {
        let packet;
        try {
          packet = JSON.parse(data[1]);
          processPacket(packet)
        } catch (e) {
          logger.error('Unable to JSON parse incoming redis packet');
        }
      })
    }else {
      blockingClient
          .pipeline()
          .brpop(opts.identity, 0)
          .lrange(opts.identity,-(this.concurrency-1),-1)
          .ltrim(opts.identity,0,-(this.concurrency))
          .exec(async (err, data) => {
            let packet;
            try {
              const packets = [data[0][1][1],...data[1][1].reverse()]
              const result = await Promise.all(packets.map(async k =>{
                try {
                  packet = JSON.parse(k);
                  await processPacketSynchronous(packet)
                }catch(e){
                  logger.error('Unable to JSON parse incoming redis packet');
                }
              }))
             //TODO: future process results based on whether error or not
              //  console.log(result)
              if(this.receiveEventsFlag){
                brPop();
              }
            } catch (e) {
              logger.error('Unable to JSON parse incoming redis packet');
            }
          });
    }

  };

  //Start receiving events
  if(this.receiveEventsFlag){
    brPop();
  }

  function processCommand (channelPattern,channel,message) {
    self.emit('command', {channelPattern,channel,message} )
  }

  function processAsyncResponseMessage(channel, message) {
    try {
      var parsedMessage = JSON.parse(message);
    } catch (e) {
      stringlog.error('Error parsing message: ' + e + ' : ' + message);
      return;
    }
    if (parsedMessage.tid) {
      processIncomingMessage(message);
    } else {
      logger.debug('Received incoming message without transactionID, skipping');
    }
  }

  function processIncomingMessage(incoming) {
    var response;
    if (Array === incoming.constructor) {
      incoming = incoming[1];
    }
    if (typeof incoming === 'string') {
      try {
        response = JSON.parse(incoming);
      } catch (e) {
        logger.error('Unable to parse incoming message as string ' + incoming + ' error: ' + e);
      }
    } else {
      response = incoming;
    }
    if (!response) {
      logger.debug('Unable to parse incoming redis message');
      return;
    }
    if (transactionIdEventEmitterMap[response.tid]) {
      logger.debug('Found listener for this transaction id, responding ' + response.tid);
      transactionIdEventEmitterMap[response.tid].emit('response', null, response);
    }
  }

  function generateHash(length) {
    if (!length) {
      length = 8;
    }
    var text = '';
    var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (var i = 0; i < length; i++)
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    return text;
  }

  function registerListener(tid,customTimeout, cb) {
    if (!transactionIdEventEmitterMap[tid]) {
      //eventEmitter.setMaxListeners(0);
      transactionIdEventEmitterMap[tid] = new events.EventEmitter();
      setTimeout(() => {
        if (transactionIdEventEmitterMap[tid]) {
          logger.debug('Timeout reached for transaction ID ' + tid + ' - emitting timeout err');
          transactionIdEventEmitterMap[tid].emit('response', {
            code:'requestTimedOut',
            message:'Request timed out. Please try again.'});
        }
      }, customTimeout?customTimeout:timeout); //15 sec default timeout
    }
    transactionIdEventEmitterMap[tid].addListener('response', (err, data, fullpacket) => {
      if (transactionIdEventEmitterMap[tid]) {
        transactionIdEventEmitterMap[tid].removeAllListeners();
        delete transactionIdEventEmitterMap[tid];
      }
      if (cb) {
        return cb(err, data, fullpacket);
      }
    });
  }

  this.emitResponse = function (tid, packet) {
    if (tid && transactionIdEventEmitterMap[tid]) {
      logger.debug('Emitting to transactionId ' + tid + ': ' + JSON.stringify(packet));
      transactionIdEventEmitterMap[tid].emit('response', null, packet);
    }
  };


  this.sendToList = (to, protocol, payload, respondTo,cb) => {
    const packet = {
      to,
      timestamp: new Date().getTime(),
      protocol,
      payload
    }
    if(respondTo) packet.respondTo = respondTo
    if (cb) {
      to = to.toLowerCase();
      localClient.lpush(to, JSON.stringify(packet), cb);
    } else {
      return new Promise((resolve, reject) => {
        localClient.lpush(to, JSON.stringify(packet), (err, res) => {
          if (err) return reject(`Unable to send to redis: ${err}`);
          resolve(res);
        });
      });
    }
  };


  this.publishPacket = (packet) => {
    if(packet && packet.respondTo){
      self.client.publish(packet.respondTo.to, JSON.stringify({
        to: packet.respondTo.to,
        from: packet.to,
        timestamp: new Date().getTime(),
        originalTimestamp: packet.timestamp,
        protocol: `${packet.protocol}-resp`,
        payload:packet.payload,
        tid: packet.respondTo.tid
      }));
    }
  };


  this.sendSync = function (to, protocol, payload, customTimeout,callback) {
    var packet = {
      to,
      from: opts.identity,
      protocol,
      timestamp: new Date().getTime(),
      payload,
      tid: generateHash()
    };

 //   logger.debug('Generated transaction id ' + packet.tid + ', publishing packet, payload:' + JSON.stringify(packet.payload));
    //TODO: Should this be done after registerListener instead to avoid any race conditions?
    localClient.lpush(packet.to, JSON.stringify(packet));

    const toLog = {...JSON.parse(JSON.stringify(packet.payload)),packetTo:packet.to,packetFrom:packet.from,packetProtocol:packet.protocol,packetTimestamp:packet.timestamp,packetTid:packet.tid,eventMessage:'Send Request',identity:opts.identity}
    if(toLog && toLog.userInfo && toLog.userInfo.credentials){
      delete toLog.userInfo.credentials
    }
    delete toLog.properties
    delete toLog.parameters
    delete toLog.inputs
    delete toLog.response
    delete toLog.output
    delete toLog.error

    if(toLog.capabilityName !== 'add'){
      toLog.originalCapabilityName = toLog.capabilityName
      toLog.capabilityName = 'add'
    }

    if(packet.to != 'eventsConnector') { //dont want to log events to events connector.
      this.sendToList('eventsConnector', 'action', toLog, null)
    }

    if (callback) {
      registerListener(packet.tid,customTimeout, (err, result, fullpacket) => {
        if (result && result.originalTimestamp) {
          const now = new Date().getTime();
          const diffRT = now - result.originalTimestamp;
          const diff = now - result.timestamp;
          logger.debug(`Calling callback for result - round trip time ${diffRT}ms, time since reply sent ${diff}ms`);
        }
        if (result && result.payload && result.payload.err) return callback(result.payload.err);
        if (result && result.payload && result.payload.res) return callback(null, result.payload.res);
        callback(err, result, fullpacket);
      });
    } else {
      return new Promise((resolve, reject) => {
        registerListener(packet.tid,customTimeout, (err, result, fullpacket) => {
          if (result && result.originalTimestamp) {
            const now = new Date().getTime();
            const diffRT = now - result.originalTimestamp;
            const diff = now - result.timestamp;
            logger.debug(`Calling callback for result - round trip time ${diffRT}ms, time since reply sent ${diff}ms`);
          }
          if (result && result.payload && result.payload.err) {
            this.sendToList('eventsConnector', 'action', {...toLog,err:result.payload.err,eventMessage:'Receive Error Response',},null)
            return reject(result.payload.err)};
          if (result && result.payload &&result.payload.res) {
            if(packet.to != 'eventsConnector') {
              this.sendToList('eventsConnector', 'action', {...toLog, eventMessage: 'Receive Response'}, null)
            }
            return resolve(result.payload.res)
          };
          reject(err);
        });
      })
    }
  };

  this.stopReceivingEvents = function (){
    this.receiveEventsFlag = false
  }

  this.startReceivingEvents = function (){
    this.receiveEventsFlag = true
    brPop();
  }

  this.publishCommand = (to,packet) => {
    if(to && packet){
      self.client.publish(`command_${to}`, JSON.stringify(packet));
    }
  };

  eventEmitter.call(this);
};

util.inherits(RedisConnector, eventEmitter);

module.exports = RedisConnector;
