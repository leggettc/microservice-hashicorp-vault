const dns = require('dns');
const axios = require('axios');

const url = require('url');
const isPrivateIP = require('private-ip');

const isURLPrivate = (urlString) => {
  const result = url.parse(urlString);
  const host = result.hostname;
  if (!host) {
    throw new Error('Invalid url');
  }
  if (host === 'localhost' || host === '127.0.0.1') {
    return true;
  }
  return isPrivateIP(host);
};

const checkForPrivateIps = (ips) => {
  if (Array.isArray(ips)) {
    let isPrivate = false;

    ips.forEach((ip) => {
      if (isPrivateIP(ip)) {
        isPrivate = true;
      }
    });

    return isPrivate;
  }

  return isURLPrivate(ips);
};

const getDNSResolvedIps = async (urlString) => {
  try {
    const parse = url.parse(urlString);
    const host = parse.hostname;

    if (!host) {
      throw new Error('Invalid url');
    }

    return await dns.promises.resolve4(host);
  } catch (e) {
    return urlString;
  }
};

function initialize(config = {}, { requestInterceptor, responseInterceptor, requestErrorInterceptor, responseErrorInterceptor } = {}) {
  const client = axios.default.create({
    ...config,
    maxRedirects: 0,
    validateStatus: status => status >= 200 && status < 400
  });
  
  const CancelToken = client.CancelToken;

  function internalErrorInterceptor(error, interceptor) {
    if (!interceptor) return Promise.reject(error);

    return interceptor(error) || Promise.reject(error);
  }
  
  async function internalRequestInterceptor(config, interceptor) {
    const resolvedIPs = await getDNSResolvedIps(config.url);
    const isPrivate = checkForPrivateIps(resolvedIPs);
    
    if (isPrivate) {
      return {
        ...config,
        cancelToken: new CancelToken((cancel) =>
        cancel('Private IPs are not allowed!')
        ),
      };
    }
    
    if (!interceptor) return config;
    return interceptor(config);
  }
  
  function internalResponseInterceptor(response, interceptor) {
    if (response.status === 301 || response.status === 302 || response.status === 303) {
      return client(response.headers.location, response.config);
    }
  
    if (!interceptor) return response;
    return interceptor(response);
  }
  
  client.interceptors.request.use(config => {
    return internalRequestInterceptor(config, requestInterceptor)
  }, error => {
    return internalErrorInterceptor(error, requestErrorInterceptor)
  });
  
  client.interceptors.response.use(response => {
    return internalResponseInterceptor(response, responseInterceptor);
  }, error => {
    return internalErrorInterceptor(error, responseErrorInterceptor);
  });

  return client;
}

async function proxyMessage (body) {
    const uri = `http://${global.SK_PROXY_CLIENT_HOST}:${global.SK_PROXY_CLIENT_PORT}/proxy`
    try {
        const response = await axios.post(uri, body,{
            headers: {
                'Content-Type': 'application/json',
            }
        });
        return response.data
    }catch(err){
        throw err.response.data
    }
}

module.exports = {
  initialize,
  getDNSResolvedIps,
  isURLPrivate,
  checkForPrivateIps,
  proxyMessage,
};