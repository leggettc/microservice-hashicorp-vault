const crypto = require('crypto');
const kms = require('../modules/kms')
const IV_LENGTH = 16
// We store the IV in the encrypted data, and the length is given below (6 bits per characters rounded up to 4 chars)
const IV_CHAR_LENGTH = 4 * Math.ceil(IV_LENGTH / 3)
/**
 *
 * @param {*} text Text to encrypt
 * @param {*} encKey Encryption key
 * @param {*} type Field type
 */
const encrypt = (text, encKey, type) =>{
  let toEncrypt
  if (type === 'number') {
    toEncrypt = text.toString()
  } else if (type === 'object') {
    toEncrypt = JSON.stringify(text)
  } else {
    // type is string
    toEncrypt = text
  }

  try {
    const iv = crypto.pseudoRandomBytes(IV_LENGTH)
    const cipher = crypto.createCipheriv('aes-256-ctr', encKey, iv)
    let crypted = cipher.update(toEncrypt, 'utf8', 'hex')
    crypted += cipher.final('hex')
    return iv.toString('base64') + crypted
  } catch (err) {
    console.log(err)
    return text
  }
}

/**
 *
 * @param {*} cipherText Encrypted text (with IV)
 * @param {*} encKey Encryption key
 * @param {*} type Type of field for parsing
 */
const decrypt = (cipherText, encKey, type) => {
  try {
    const iv = cipherText.substring(0, IV_CHAR_LENGTH)
    const decipher = crypto.createCipheriv('aes-256-ctr', encKey, Buffer.from(iv, 'base64'))
    let dec = decipher.update(cipherText.substring(IV_CHAR_LENGTH), 'hex', 'utf8')
    dec += decipher.final('utf8')

    if (type === 'number') {
      return Number(dec)
    }
    if (type === 'object') {
      return JSON.parse(dec)
    }

    return dec
  } catch (err) {
    console.log(err)
    return cipherText
  }
}


const companyRecordEncrypt = (props) =>{
  let encrypted = {...props};

  if(props && props.jwtKeys && props.jwtKeys.pairs && props.jwtKeys.pairs.length >0) {
    for (let i=0;i<encrypted.jwtKeys.pairs.length;i++){
      if(encrypted.jwtKeys.pairs[i].privateKey){
        const encryptedKey = encrypt(encrypted.jwtKeys.pairs[i].privateKey, Buffer.from(global.secrets.encryption.key,'hex'))
        encrypted.jwtKeys.pairs[i].privateKey =encryptedKey;
      }
    }
  }

  if(props && props.samlKeys && props.samlKeys.privateKey){
    encrypted.samlKeys.privateKey = encrypt(encrypted.samlKeys.privateKey, Buffer.from(global.secrets.encryption.key,'hex'))
  }
  return encrypted

}


const companyRecordDecrypt = async (props) =>{
  let decrypted = {...props};
  const securityType = props.securityType || 'default'

  if(props && props.jwtKeys && props.jwtKeys.pairs && props.jwtKeys.pairs.length >0) {

    for (let i = 0; i < decrypted.jwtKeys.pairs.length; i++) {
      if (decrypted.jwtKeys.pairs[i].privateKey) {
        if(securityType === 'default') {
          decrypted.jwtKeys.pairs[i].privateKey = decrypt(decrypted.jwtKeys.pairs[i].privateKey, Buffer.from(global.secrets.encryption.key, 'hex'))
        }else if (securityType === 'kms') {
          const decObj = await kms.decrypt(props.securityProps.Arn,Buffer.from(decrypted.jwtKeys.pairs[i].privateKey,'base64'))
          decrypted.jwtKeys.pairs[i].privateKey = decObj.Plaintext.toString()
        }
      }
    }
  }
  if(props && props.samlKeys && props.samlKeys.privateKey) {
    if(securityType === 'default') {
      decrypted.samlKeys.privateKey = decrypt(decrypted.samlKeys.privateKey, Buffer.from(global.secrets.encryption.key, 'hex'))
    }else if (securityType === 'kms') {
      const decObj = await kms.decrypt(props.securityProps.Arn,Buffer.from(decrypted.samlKeys.privateKey,'base64'))
      decrypted.samlKeys.privateKey = decObj.Plaintext.toString()
    }
  }
  return decrypted

}

const generateHash = (length) => {
  if (!length) {
    length = 8;
  }
  var text = '';
  var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (var i = 0; i < length; i++)
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  return text;
}


const filterSensitiveDataFromCredential = userInfo => {
  if(!(userInfo && userInfo.credentials)) {
    return userInfo;
  }
  let updatedUserInfo = userInfo;

  updatedUserInfo.credentials.map((credential) => {
    if(credential.skType === 'recoveryCodes') {
      if(credential.details && credential.details.raw && credential.details.raw.codes) {
        delete credential.details.raw.codes;
      }
    }
    return credential;
  });

  return updatedUserInfo;
}

const getRecoveryCodes = userInfo => {
  if(!userInfo.credentials) {
    return [];
  }
  let recoveryCodes = [];

  userInfo.credentials.forEach((credential) => {
    if(credential.skType === 'recoveryCodes') {
      if(credential.details && credential.details.raw && credential.details.raw.codes) {
        recoveryCodes = credential.details.raw.codes
      }
    }
  });

  return recoveryCodes;
}

const dotNotationToValue = (obj,str) =>{
  try {
    return str.split('.').reduce((o,i)=>o[i], obj)
  }catch(err){
    return obj[str]
  }
}

module.exports = {
  companyRecordEncrypt,
  companyRecordDecrypt,
  generateHash,
  filterSensitiveDataFromCredential,
  getRecoveryCodes,
  dotNotationToValue
}
