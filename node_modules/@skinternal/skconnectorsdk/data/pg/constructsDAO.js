/**
 * Created by hiteshkalra on 7/12/19.
 */
const constants = require('../../config/constants'),
      _ = require('lodash')
;

const collectionName = constants.constructsTable;


const getConstructsBatch = async (constructsList) =>{
  if(constructsList.length === 0 ){
    return []
  }
  const constructListQuery = []
  let nextParamIndex = 1
  const queryParams = []
  constructsList.forEach(k=>{
    queryParams.push(`${k.name}`)
    queryParams.push(`${k.companyId}`)
    constructListQuery.push(`(name = $${nextParamIndex} AND companyId = $${nextParamIndex+1})`)
    nextParamIndex += 2
  })
  const query = `
    SELECT * FROM ${collectionName} 
    WHERE ${constructListQuery.join(' OR ')}
    ;
    `;
  try {
    const response = await global.pg.query(query,queryParams);
    if (!(response && response.rows && Array.isArray(response.rows) &&  response.rows.length >0)){
      return
    }
    return response.rows.map(k=>{
      return {_id: {name:k.name,companyId: k.companyid}, ...k.data}
    })
  } catch (err) {
    console.log(err)
    console.log('getConstuctsBatchError')
    console.log(constructListQuery)
    throw err
  }
}


const getConstructsList = async (constructsList,recursive) => {
  if(!(constructsList && constructsList.length > 0)) {
    return []
  }

  let response = []

  let constructsListFinal = constructsList.map(k => {
    let name;
    let companyId;

    if (typeof k === 'string') {
      name = k
      companyId = 'singularkey'
    } else {
      name = k.name
      companyId = k.companyId
    }

    return {name,companyId};

  })

  let tmpResponse = await getConstructsBatch(constructsListFinal.filter(k=>k !=null))
  if(tmpResponse) {
    response = response.concat(tmpResponse)
  }

  response = response.filter(k=>k != null)

  if(recursive) {
    let tmpResponse = null
    if(response && response.length > 0) {

      tmpResponse = await Promise.all(response.map(async k=>{
        if (k && k.props && k.props.properties){
          const tmpResp = await getConstructsList(k.props.properties,false)
          return tmpResp
        }
      }))
    }
    if (tmpResponse) {
      response = _.flatten(response.concat(tmpResponse))
    }
  }
  return response;
}

const getConstructsListAdvanced = async (constructsList,recursive) => {
  if(!(constructsList && constructsList.length > 0)) {
    return []
  }

  let properties = {};
  let response = []
  let constructsListFinal = constructsList.map(k => {
    let name;
    let companyId;
    if (typeof k === 'string') {
      name = k
      companyId = 'singularkey'
    } else {
      name = k.name
      companyId = k.companyId
    }

    return {name,companyId};
  })


  let tmpResponse = await getConstructsBatch(constructsListFinal.filter(k=>k !=null))
  if(tmpResponse){
    response = response.concat(tmpResponse)
  }
  response = response.filter(k=>k != null)

  if (recursive) {

    let tmpResponse = null
    if (response && response.length > 0) {

      try {
        tmpResponse = await Promise.all(response.map(async k => {
          let record = {}

          record[k._id.name] = {...k.fields,type:k.type,visibility:k.visibility,createdDate:k.createdDate,customerId:k.customerId,companyId:k._id.companyId}
          if (k && k.fields && k.fields.constructItems) {
            const tmpResp = await getConstructsList(k.fields.constructItems, false)

            if (tmpResp && tmpResp.length > 0) {
              delete record[k._id.name].properties;
              record[k._id.name].properties = {};
              tmpResp.map(m => {
                if(m) {
                  record[k._id.name].properties[m._id.name] = m.fields
                }
              })
            }
          }
          properties = {...properties,...record}
          return record
        }))
        console.log("Done with Promise")
      }catch(err){
        console.log(" getConstructsListAdvanced Promise All Error")
        console.log(err)
      }

    }
    return properties;
  }

  return response
}

module.exports = {
  getConstructsList,
  getConstructsListAdvanced,
}