const constants = require('../../config/constants');
const db = global.mongoDB;
const {serr} = require('../../modules/singularError');
const myCollection = db.collection(constants.appUsersTable);
const {getRecoveryCodes, filterSensitiveDataFromCredential} = require('../../modules/util');

const getUserByUserId = (userId,companyId,connectionId) => {
  const query = {userId, '_id.companyId': companyId};
  
  return new Promise((resolve,reject) => {
    myCollection.findOne(query, (err,response) =>{
      if(err) {
        console.log (err);
        return reject(err)
      }
      const userInfo = filterSensitiveDataFromCredential(response);
      resolve(userInfo)
    })
  })
}

const incrementVariable = (userId,companyId,key,value) =>{
  const query = {userId,'_id.companyId':companyId};

  const variablesKey = `variables.${key}`
  const update = {$inc:{}}
  update.$inc[variablesKey] = value;
  
  const options = {
    returnDocument: 'after'
  };

  return new Promise((resolve,reject) => {
    myCollection.findOneAndUpdate(query, update, options, (err,response)=>{
      if(err) {
        console.log(err);
        return reject(err);
      }
      resolve(response.value);
    })
  })
}


const saveVariable = (userId,companyId,key,value) =>{
  const query = {userId,'_id.companyId':companyId};

  let variablesKey = `variables.${key}`
  const update = {$set:{}}
  update.$set[variablesKey] = value
  
  const options = {
    returnDocument: 'after'
  };

  return new Promise((resolve,reject) => {
    myCollection.findOneAndUpdate(query, update, options, (err,response)=>{
      if(err) {
        console.log(err);
        return reject(err);
      }
      resolve(response.value);
    })
  })
}

const createCredential = ({
  userId,
  companyId,
  credential,
  uniqueProperties,
}) => {
  if (credential && !credential.createdDate) {
    credential.createdDate = Date.now();
  }
  const user = { userId, '_id.companyId': companyId };

  const query = user;
  const update = {
    $push: {
      credentials: { ...credential },
    },
  };
  const options = {
    returnDocument: 'after'
  };

  if (!uniqueProperties) {
    return new Promise((resolve, reject) => {
      myCollection.findOneAndUpdate(query, update, options, (err, response) => {
        if (err) {
          console.log(err);
          return reject(err);
        }
        resolve(response.value);
      });
    });
  } else {
    let credFilter = { ...user };
    uniqueProperties.map((k) => {
      const key = `credentials.${k.key}`;
      credFilter[key] = `${k.value}`;
    });

    return new Promise((resolve, reject) => {
      myCollection.find(credFilter).toArray((err, response) => {
        if (err) {
          console.log(err);
          return reject(err);
        }
        if (response && response.length > 0) {
          return reject(
            new serr('CreadentialExistError', {
              message: 'Credential Already Exists',
            })
          );
        }
        myCollection.findOneAndUpdate(query, update, options, (err, response) => {
          if (err) {
            console.log(err);
            return reject(err);
          }
          resolve(response.value);
        });
      });
    });
  }
};
const saveVariables = (userId,companyId,props) =>{
  const query = {userId,'_id.companyId':companyId};

  const update = {$set:{}}
  Object.keys(props).forEach(key=>{
    let variablesKey = `variables.${key}`
    update.$set[variablesKey] = props[key]
  })

  const options = {
    returnDocument: 'after'
  };

  return new Promise((resolve,reject) => {
    myCollection.findOneAndUpdate(query, update, options, (err,response)=>{
      if(err) {
        console.log(err);
        return reject(err);
      }
      resolve(response.value);
    })
  })
}

const deleteCredential = ({userId,companyId,credId}) => {
  const query = {userId, '_id.companyId': companyId};

  const update = {
    $pull: {
      credentials: {
        credId: credId
      }
    }
  };

  return new Promise((resolve, reject) => {
    myCollection.updateOne(query, update, (err, response) => {
      if (err) {
        console.log(err);
        return reject(err)
      }
      resolve({
        n: response.matchedCount,
        ok: response.acknowledged ? 1 : 0,
        nModified: response.modifiedCount
      })
    })
  })
}


const updateCredential = ({userId,companyId,credId,status,customFields}) => {

  const query = {userId,'_id.companyId':companyId,
    "credentials.credId": credId
  };

  const update = {}

  if(status){
    if(!update['$set']) update['$set'] = {}
    update['$set']['credentials.$.status']  = status
  }

  if(customFields && Object.keys(customFields).length > 0){
    if(!update['$set']) update['$set'] = {}
    Object.keys(customFields).forEach(k=>{
      update['$set'][`credentials.$.details.raw.${k}`]  = customFields[k]
    })
  }

  const options = {
    returnDocument: 'after'
  };

  return new Promise((resolve,reject) => {
    myCollection.findOneAndUpdate(query, update, options, (err,response)=>{
      if(err) {
        console.log(err);
        return reject(err);
      }
      resolve(response.value);
    })
  })
}

const getUserByAlias = (companyId,userAlias) => {
  const query = {userAlias, '_id.companyId': companyId};

  return new Promise((resolve,reject) => {
    myCollection.findOne(query, (err,response) =>{
      if(err) {
        console.log (err);
        return reject(err)
      }
      const userInfo = filterSensitiveDataFromCredential(response);
      resolve(userInfo)
    })
  })
}

const getUserByConnectionIdEmail = (companyId,connectionId,email) => {
  const query = {email, '_id.companyId': companyId, '_id.connectionId': connectionId};

  return new Promise((resolve,reject) => {
    myCollection.findOne(query, (err,response) =>{
      if(err) {
        console.log (err);
        return reject(err)
      }
      const userInfo = filterSensitiveDataFromCredential(response);
      resolve(userInfo)
    })
  })
}

const getUser = (companyId,connectionId,username) => {
  let props = {_id:{username,companyId,connectionId}}
  return new Promise((resolve,reject) => {
    myCollection.findOne(props, (err,response) =>{
      if(err) {
        console.log (err);
        return reject(err)
      }
      const userInfo = filterSensitiveDataFromCredential(response);
      resolve(userInfo)
    })
  })
}

const updateUser = (userId,companyId,props,passwordHistoryProps) => {
  const user = {userId,'_id.companyId':companyId}
  const update = {
    $set: props
  };

  if(passwordHistoryProps && passwordHistoryProps.previousPassword){
    update.$push = {
      passwordHistory: {
        $each:[passwordHistoryProps.previousPassword],
        $slice: -passwordHistoryProps.totalPreviousPasswordsCount
      }
    }
  }

  const options = {
    returnDocument: 'after'
  };

  return new Promise((resolve,reject) => {
    myCollection.findOneAndUpdate(query, update, options, (err,response)=>{
      if(err) {
        console.log(err);
        return reject(err);
      }
      resolve(response.value);
    });
  });
};

const getUserRecoveryCodes = (userId,companyId) => {
  const query = {userId, '_id.companyId': companyId};

  return new Promise((resolve,reject) => {
    myCollection.findOne(query, (err,response) =>{
      if(err) {
        console.log (err);
        return reject(err)
      }
      const recoveryCodes = getRecoveryCodes(response);
      resolve(recoveryCodes)
    })
  })
}

module.exports = {
  getUserByUserId,
  incrementVariable,
  saveVariable,
  createCredential,
  saveVariables,
  deleteCredential,
  updateCredential,
  getUserByConnectionIdEmail,
  getUser,
  updateUser,
  getUserByAlias,
  getUserRecoveryCodes
}