/**
 * Created by hiteshkalra on 9/7/19.
 */

let secretsClient = null,
    mongoClient = null,
    appsDAO = null,
    eventsDAO = null,
    companyDAO = null,
    flowsDAO = null,
    flowVersionsDAO = null,
    redisDAO = null,
    usersDAO = null,
    mdsDAO = null,
    devicesDAO = null,
    redisClient = null,
    connectionsApp  = null,
    connectorsApp  = null,
    flowsApp  = null,
    healthCheckApp  = null,
    hashRing = null,
    connectorManifest = null,
    resolveToFieldToConnector =true,
    handleCapability=true,
    logUserEvents = true,
    doNotUpdateCIProps = false,
    util = null,
    Redis = null,
    identity = null,
    globalListName = null,
    shard = false,
    //**** Web Server Related Start ****//
    webServerMode = process.env.SK_CONNECTOR_WEBSERVER_SUPPRESS && process.env.SK_CONNECTOR_WEBSERVER_SUPPRESS.trim() === "true"?false:true,
    httpServer = null,
    express = null,
    app = null,
    bodyParser = null,
    router = null,
    globalRoute =  null,
//**** Web Server Related End ****//
    slack = null,
    upload = null,
    methods = () =>{};
global.Redis = null;

let queueOpts = {
  enabled: false,
  limit: 5,
  delay: 5000,
  concurrency: 2,
  paused: false,
};

const {compileErr, serr,curriedSerr} = require('./modules/singularError'),
    os = require('os'),
    _ = require('lodash'),
    Ajv = require('ajv'),
    {logger,setLogLevel} = require('@skinternal/sk-logger');

const memory = require('./modules/memory');

const async = require('async');
const { version } = require('./package.json');

let packetQueue;

ajv = Ajv({allErrors: true});

const crypto = require('crypto'),
    uuidv4 = require('uuid/v4'),
    base64url = require('base64url');
const { PROCESS_EXIT_BLACKLIST } = require('./config/constants');

const randomBase64URLBuffer = (len) => {
  len = len || 32;
  let buff = crypto.randomBytes(len);
  return base64url(buff);
}

const getCompany = (companyId) => {
  return companyDAO.getCompany(companyId);
};


const storeChallengeDB = (props) => {
  return eventsDAO.createEvent(props);
};

const getChallengeDB = (challengeId) => {
  return eventsDAO.getEvent(challengeId);
};

const updateChallengeStatusDB = (challengeId,status,updatedBy,props) =>{
  return eventsDAO.updateEventStatus(challengeId,status,updatedBy,props);
};

const getUserByUserId = async (userId,companyId,connectionId) =>{
  try {
    const userInfo = await usersDAO.getUserByUserId(userId,companyId,connectionId);
    if(userInfo && userInfo._id){
      userInfo.username = userInfo._id.username;
      delete userInfo.salt;
      delete userInfo.hashedPassword;
      delete userInfo._id;
      if (userInfo.credentials && userInfo.defaultCredId ) {
        userInfo.credentials = userInfo.credentials.map(k=>{
          if(k.credId == userInfo.defaultCredId) {
            k.default = true;
          }
          return k
        })
      }
    }
    return userInfo
  }  catch(err){
    throw err
  }
};

const getConnectionDetails = (companyId,connectionId) =>{
  return connectionsApp.getConnectionDetails(companyId,connectionId)
}

const mdsDAO_getAll = () => {
  return mdsDAO.getAll();
};

const mdsDAO_updatePayload  = (id,payload,returnNew) =>{
  return mdsDAO.updatePayload(id,payload,returnNew)
}

const mdsDAO_createRecord = (id,env,type,payload,tocId) =>{
  return mdsDAO.createRecord(id,env,type,payload,tocId)
}

const devicesDAO_getDevice = (id) =>{
  return devicesDAO.getDevice(id)
}

const appsDAO_getApp = (companyId,appId) =>{
  return appsDAO.getApp(companyId,appId)
}

const usersDAO_incrementVariable = (userId,companyId,key,value) => {
  return usersDAO.incrementVariable(userId,companyId,key,value);
};

const usersDAO_saveVariable = (userId,companyId,key,value) => {
  return usersDAO.saveVariable(userId,companyId,key,value);
};

const usersDAO_saveVariables = (userId,companyId,props) => {
  return usersDAO.saveVariables(userId,companyId,props);
};


const usersDAO_getUserByConnectionIdEmail = (companyId,connectionId,email) => {
  return usersDAO.getUserByConnectionIdEmail(companyId,connectionId,email);
};

const usersDAO_getUser = (companyId,connectionId,username) => {
  return usersDAO.getUser(companyId,connectionId,username);
};

const usersDAO_getUserByAlias = (companyId,userAlias) => {
  return usersDAO.getUserByAlias(companyId,userAlias);
};

const usersDAO_updateUser = (userId,companyId,props,passwordHistoryProps) => {
  return usersDAO.updateUser(userId,companyId,props,passwordHistoryProps);
};



const redisDAO_updateInteractionVariables = (interactionId,props) => {
  return redisDAO.updateInteractionVariables(interactionId,props);
};

const redisDAO_incrementInteractionVariable = (interactionId,variable,incrementBy) => {
  return redisDAO.incrementInteractionVariable(interactionId,variable,incrementBy);
};


const startSessionRedisOpenIdCode = (key,props,returnProps) =>{
  return redisDAO.startSessionRedisOpenIdCode(key,props,returnProps)
}

const redisSendSync = async(to,protocol,payload,customTimeout) =>{
  if(to === 'oe') {
    to =  await hashRing.getInstanceByCH(to,payload.interactionId)
    console.log(`Instance by CS for interactionId ${payload.interactionId}: ${to} `)
  }
  return Redis.sendSync(to, protocol, payload,customTimeout)
}
const redisPublish  = async (packet)=>{
  return Redis.publishPacket(packet)
}

const redisPublishCommand  = async (to,packet)=>{
  return Redis.publishCommand(to,packet)
}

const sensitiveReplacement = '******'
const removeSensitiveInfo = (toLog) =>{
  if(!toLog) return toLog

  if (toLog.userInfo) {
    toLog.userId = toLog.userInfo.userId
    toLog.username = toLog.userInfo.username
    toLog.email = toLog.userInfo.email
    toLog.userInfo  = sensitiveReplacement
  }

  if (toLog.parameters && toLog.parameters.interactionInfo) {
    toLog.parameters.interactionInfo = sensitiveReplacement
  }

  if(toLog.oauth2){
    toLog.oauth2 = sensitiveReplacement
  }
  return toLog
}

const processPacket = async (packet, callback,httpCallback) => {
  const startTime = process.hrtime()
  let toLog;
  if(logUserEvents){
    toLog = {...JSON.parse(JSON.stringify(packet.payload)),packetTo:packet.to,packetFrom:packet.from,packetProtocol:packet.protocol,packetTimestamp:new Date().getTime(),packetTid:packet.tid,eventMessage:'Receive Request',identity,capabilityName:'add',originalCapabilityName:packet.payload.capabilityName}
    if(!(packet.payload && packet.payload.debugMode)){
      delete toLog.properties
      delete toLog.parameters
      delete toLog.inputs
    }
    Redis.sendToList('eventsConnector', 'action', removeSensitiveInfo(toLog),null)
  }
  if (packet.timestamp) {
    const diff = new Date().getTime() - packet.timestamp;
    logger.debug(`Processing packet received ${diff} ms ago`);
  }
  try {

    let originalProperties = (packet && packet.payload && packet.payload.properties) ? {...packet.payload.properties} : {}
    if (resolveToFieldToConnector && packet && packet.payload && packet.payload.companyId && packet.payload.connectionId) {
      const cds = await getConnectionDetails(packet.payload.companyId, packet.payload.connectionId)
      packet = {...packet, ...cds}  // for backward compatibility
      if (cds.connection) {
        packet.payload.connection = {connectionId: cds.connection.connectionId, connectorId: cds.connection.connectorId}  // For push notification for example
        if (cds.connection.properties) {
          if (packet.payload.properties) {
            packet.payload.properties = _.merge(cds.connection.properties, packet.payload.properties)
          } else {
            packet.payload.properties = cds.connection.properties
          }
        }

      }
    } else if (resolveToFieldToConnector && packet && packet.to) {
      //TODO: Need to check when is this used -
      const cds = await connectorsApp.getConnectorDetails(packet.to)
      packet = {...packet, ...cds} // for backward compatibilty
      if (cds.connector && cds.connector.properties) {
        if (packet.payload.properties) {
          packet.payload.properties = _.merge(cds.connector.properties, packet.payload.properties)
        } else {
          packet.payload.properties = cds.connector.properties
        }

      }
    }
    if (!packet.payload.properties) {
      packet.payload.properties = {}
    }
    if (!packet.payload.parameters) {
      packet.payload.parameters = {}
    }

    if (resolveToFieldToConnector) {   // so that it doesnt affect oe and its functions capability
      //remove value from properties
      let c = {}
      Object.keys(packet.payload.properties).forEach(k => {
        if (typeof packet.payload.properties[k].value != 'undefined') {
          c[k] = packet.payload.properties[k].value
          if(k === 'authType' && packet.payload.properties[k].value === 'customAuth' &&
              packet.payload.properties.customAuth &&
              packet.payload.properties.customAuth.properties) {
            Object.keys(packet.payload.properties.customAuth.properties).forEach(authProperty => {
              if (typeof packet.payload.properties.customAuth.properties[authProperty].value != 'undefined') {
                c[authProperty] = packet.payload.properties.customAuth.properties[authProperty].value
              }
            })
          }
        }else if (typeof packet.payload.properties[k].properties === 'object'){ //support for screen0Config ..
          c[k] = packet.payload.properties[k]
        }
      })

      packet.payload.properties = c
    }

    let response
    let sendUnwrappedResponse = false
    if (handleCapability) {
      if (resolveToFieldToConnector) {
        if(packet.payload.properties[`${packet.payload.capabilityName}_localizedErrors`] && packet.payload.properties[`${packet.payload.capabilityName}_localizedErrors`].properties){
          packet.payload.serr = curriedSerr(packet.payload.properties[`${packet.payload.capabilityName}_localizedErrors`].properties)
        }else {
          packet.payload.serr = serr
        }
        let payloadInputSchema
        if (packet.payload.eventName) {
          payloadInputSchema = (connectorManifest.capabilities[packet.payload.capabilityName] && connectorManifest.capabilities[packet.payload.capabilityName].payloadInputSchema && connectorManifest.capabilities[packet.payload.capabilityName].payloadInputSchema[packet.payload.eventName]) ? connectorManifest.capabilities[packet.payload.capabilityName].payloadInputSchema[packet.payload.eventName] : null
        } else {
          payloadInputSchema = (connectorManifest.capabilities[packet.payload.capabilityName] && connectorManifest.capabilities[packet.payload.capabilityName].payloadInputSchema && connectorManifest.capabilities[packet.payload.capabilityName].payloadInputSchema.default) ? connectorManifest.capabilities[packet.payload.capabilityName].payloadInputSchema.default : null

        }
        if (payloadInputSchema) {
          console.log(payloadInputSchema)
          try {
            const valid = ajv.validate(payloadInputSchema, packet.payload);
            if (valid) {
              console.log('Payload is valid');
            } else {
              console.log('Payload is INVALID!');
              throw new serr('validationError', {details: ajv.errors})
            }
          } catch (err) {
            console.log('validation error')
            console.log(err)
            if (err instanceof serr) {
              throw err
            }
            throw new serr('internalValidationError', {httpResponseCode: 500})
          }
        } else {
          console.log("DID NOT VALIDATE Payload")
        }
      }

      const funcName = (packet.payload.eventName) ? `handle_capability_${packet.payload.capabilityName}_${packet.payload.eventName}` : `handle_capability_${packet.payload.capabilityName}`
      if (packet.protocol === 'action') {
        if (!methods[funcName] && connectorManifest && connectorManifest.capabilities && connectorManifest.capabilities[packet.payload.capabilityName] && connectorManifest.capabilities[packet.payload.capabilityName].respondToUser) {
          //this is required so that we put the .value back in the properties. it is needed by the API to merge when responding to the user view
          packet.payload.properties = originalProperties
          if(Object.keys(originalProperties).length > 0 && !doNotUpdateCIProps){
            console.log(`${identity}: ci1`)
            await redisDAO.updateSessionRedisOpenIdAuthPage(packet.payload.interactionId,{[`ciProps_${packet.payload.connectionId}_${packet.payload.id}`]:originalProperties})
          }
          //Respond right away
          response = methods.respondTouser(packet)
        } else {
          if(Object.keys(originalProperties).length > 0 && !doNotUpdateCIProps){
            console.log(`${identity}: ci2`)
            await redisDAO.updateSessionRedisOpenIdAuthPage(packet.payload.interactionId,{[`ciProps_${packet.payload.connectionId}_${packet.payload.id}`]:originalProperties})
          }
          if (methods[`handle_capability_${packet.payload.capabilityName}`]) {
            response = await methods[`handle_capability_${packet.payload.capabilityName}`](packet.payload)
            //reconvert properties n/v pairs to n/value objects. i.e., from name:value to  name:{value:'key'}
            if (response && response.payload && response.payload.properties) {
              const tmpProps = {}
              Object.keys(response.payload.properties).forEach(k => tmpProps[k] = (k ==='screen0Config')?response.payload.properties[k] :{value: response.payload.properties[k]})
              response.payload.properties = tmpProps
            }
          } else {
            console.log(`Please implement methods.handle_capability_${packet.payload.capabilityName}`)
            //Backward compatibility
            response = await methods.processEvent(packet)
          }
        }
      } else if (packet.protocol === 'trigger') {
        if (methods[funcName]) {
          response = await methods[funcName](packet.payload)
        } else {
          console.log(`Please implement ${funcName}`)
          //Backward compatibility
          response = await methods.processEvent(packet)
        }

      } else if (packet.protocol === 'webhook') {
        const funcName = (packet.payload.capabilityName) ? `handle_webhook_${packet.payload.capabilityName}` : `handle_webhook`

        if (methods[funcName]) {
          response = await methods[funcName](packet.payload)
        } else {
          console.log(`Please implement methods.${funcName}`)
          //Backward compatibility
          response = await methods.processEvent(packet)
        }
      } else {
        return new serr('unSupportedProtocolError', {message: 'protocol not supported'})
      }

      if (packet.payload && connectorManifest && packet.payload.capabilityName && connectorManifest.capabilities[packet.payload.capabilityName] && connectorManifest.capabilities[packet.payload.capabilityName].unwrapped) {
        sendUnwrappedResponse = true
      }

    } else {
      response = await methods.processEvent(packet) //For example in case of oe
    }

    delete packet.connection //TODO: Make sure it is ok to delete this. Initially it was for logging less events
    delete packet.connector //TODO: Make sure it is ok to delete this. Initially it was for logging less events
    if (response === null && callback) {    //This is the case where oe explictly returns null...
      return callback(null, null)
    }

    if (!sendUnwrappedResponse) {
      if (typeof response === 'undefined') {  //This is the case where there is no return, by explicitly it is considered success
        response = {success: true}
      } else if (response != null && typeof response === 'object') { //This is the case when there is a return and it is not null (not typeof null is also an object - will work for OE scenario)
        response.success = true
      }
    }

    if(logUserEvents) {
      if (packet.payload.debugMode && response && response.action !== 'sendUserView'){
        toLog.response = response
      }

      if(originalProperties.globalVariableMapping && originalProperties.globalVariableMapping.value && originalProperties.globalVariableMapping.value.length > 0) {
        toLog.globalVariables = {}
        originalProperties.globalVariableMapping.value.forEach(item => {
          if (item && item.name && item.value) {
            toLog.globalVariables[item.name] = util.dotNotationToValue(response, item.value)
          }
        })
      }

      //Run it through a function that will
      toLog.success = true
      toLog.eventMessage = 'Send Response'
      toLog.packetTimestamp = new Date().getTime()
      const endTime = process.hrtime(startTime)
      toLog.executionTime = ((endTime[0] * 1e9) + endTime[1])/ 1e6;
      Redis.sendToList('eventsConnector', 'action', removeSensitiveInfo(toLog), null)
    }

    if(!sendUnwrappedResponse) {
      //api will use this information so send to OE to continue the flow - so that we know which connector is sending this response
      //Spread response at the end - so that the connector developer can override the interactionId (like in case of Jumio webhook)
      response = {
        interactionId: packet.payload.interactionId,
        companyId: packet.payload.companyId,
        connectionId: packet.payload.connectionId,
        connectorId: packet.payload.connectorId,
        id: packet.payload.id,
        capabilityName: packet.payload.capabilityName,
        ...response
      }
    }

    if(response.eventName === 'doNotContinue' && response.au){
      //response.event = 'continue'
      await redisDAO.updateSessionRedisOpenIdAuthPage(packet.payload.interactionId,{[`auProps_${response.au}`]:response})
      return callback(null, null)
    }

    let propsToSave
    if(response.userInfo){
      propsToSave = {userInfo:response.userInfo}
    }
    if(response.ciPropsToSave){
      if(!propsToSave){
        propsToSave = {}
      }
      const tmpCiPropsToSave = {}
      Object.keys(response.ciPropsToSave).forEach(p=>{
        tmpCiPropsToSave[p] = {value:response.ciPropsToSave[p]}
      })
      if(Object.keys(originalProperties).length > 0 && !doNotUpdateCIProps){
        propsToSave[`ciProps_${packet.payload.connectionId}_${packet.payload.id}`] = {...originalProperties,...tmpCiPropsToSave}
      }else {
        propsToSave[`ciProps_${packet.payload.connectionId}_${packet.payload.id}`] = tmpCiPropsToSave
      }
    }
    if(propsToSave){
      await redisDAO.updateSessionRedisOpenIdAuthPage(packet.payload.interactionId,propsToSave)
    }

    if(response && callback) return callback(null, response)  //Default case, where if response is null, there is no callback. else if response is defined and callback is defined it works.
    if(httpCallback){
      return response && response.output?response.output:{}
    }
  } catch(err){
    console.log(err)
    if(logUserEvents) {
      toLog.success = false
      toLog.err = err
      toLog.eventMessage = 'Send Error Response'
      toLog.packetTimestamp = new Date().getTime()
      const endTime = process.hrtime(startTime)
      toLog.executionTime = ((endTime[0] * 1e9) + endTime[1])/ 1e6;
      if(toLog.err && toLog.err.stack){
        delete toLog.err.stack
      }
      Redis.sendToList('eventsConnector', 'action', removeSensitiveInfo(toLog), null)
    }

    err = {
      interactionId: packet.payload.interactionId,
      companyId: packet.payload.companyId,
      connectionId: packet.payload.connectionId,
      connectorId: packet.payload.connectorId,
      id: packet.payload.id,
      capabilityName: packet.payload.capabilityName,
      ...err
    }
    if(callback) callback(err)
    if(httpCallback) throw err
  }
};

const queueProcessPacket = async (packet, callback, httpCallback) => {
  // If queue is not enabled, forward to processPacket
  if (!queueOpts.enabled) return processPacket(packet, callback, httpCallback);

  // Push packet to queue
  packetQueue && packetQueue.push({
    packet,
    callback,
    httpCallback
  }, (err) => {
    // Check if queue limit has reached
    if (packetQueue.length() >= queueOpts.limit && !queueOpts.paused) {
      // Pause the queue for a time delay
      packetQueue.pause();
      queueOpts.paused = true;

      // Resume the queue after depay
      setTimeout(() => {
        packetQueue.resume();
        queueOpts.paused = false;
      }, queueOpts.delay);
    }
  });
}

const processCommand = (commandObj) =>{
  console.log("In sdk processing command")
  console.log(commandObj)
  try {
    const parsedMessage = JSON.parse(commandObj.message)
    //TODO: check channel and only run the two commands if channel matches.
    if(parsedMessage.destination === 'connector') {
      methods.connectorProcessCommand(parsedMessage,commandObj.channel,commandObj.channelPattern)
      return
    }

    if(parsedMessage.command === 'invalidateConnectionFromCache') {
      const {companyId,connectionId } = parsedMessage
      console.log('invalidateConnectionFromCache')
      console.log(companyId,connectionId)
      connectionsApp.invalidateConnectionFromCache(companyId,connectionId)
      methods.connectorProcessCommand(parsedMessage, commandObj.channel, commandObj.channelPattern)
    } else if(parsedMessage.command === 'invalidateAllConnectionFromCache') {
      connectionsApp.invalidateAllConnectionsFromCache()
    }else if(parsedMessage.command === 'invalidateFlowFromCache'){
      const {companyId,flowId } = parsedMessage
      console.log('invalidateFlowFromCache')
      console.log(companyId,flowId)
      flowsApp.invalidateFlowFromCache(companyId,flowId)
      methods.connectorProcessCommand(parsedMessage,commandObj.channel,commandObj.channelPattern)
    } else if (parsedMessage.command === 'rebalance'){
      if(parsedMessage.props && parsedMessage.props.action === 'update' && parsedMessage.props.microserviceIdentity && parsedMessage.props.instances && Array.isArray(parsedMessage.props.instances) && parsedMessage.props.instances.length >0 )
        hashRing.updateHashRingForMS(parsedMessage.props.microserviceIdentity,parsedMessage.props.instances)
    }else if(parsedMessage.command) {
      methods.connectorProcessCommand(parsedMessage, commandObj.channel, commandObj.channelPattern)
    }
  }catch(err){
    console.log("err")
    console.log(err)
  }
}

methods.connectorProcessCommand = async(event,channel,channelPattern) =>{
}

methods.processEvent = async (packet) => {
  throw {success: false, message: "Method not implemented"}
}

methods.respondTouser = (packet) =>{
  return {action:'sendUserView',payload:packet.payload}
}

methods.sendActionUserView = async (packet) => {

  Redis.sendToList(packet.to, packet.protocol, packet.payload, {to: 'api', tid: packet.tid, publish: true})
  if (logUserEvents) {
    const toLog = {...JSON.parse(JSON.stringify(packet.payload)),packetTo:packet.to,packetFrom:packet.from,packetProtocol:packet.protocol,packetTimestamp:packet.timestamp,packetTid:packet.tid, eventMessage: 'Send Response', identity,capabilityName:'add'}
    Redis.sendToList('eventsConnector', 'action', removeSensitiveInfo(toLog), null)
  }
}

methods.sendAction = async (packet) => {
  Redis.sendToList(packet.to,packet.protocol,packet.payload,{to:globalListName,publish:false})
  if(logUserEvents) {
    const toLog = {...JSON.parse(JSON.stringify(packet.payload)),packetTo:packet.to,packetFrom:packet.from,packetProtocol:packet.protocol,packetTimestamp:packet.timestamp,packetTid:packet.tid, eventMessage: 'Send Response', identity,capabilityName:'add'}
    Redis.sendToList('eventsConnector', 'action', removeSensitiveInfo(toLog), null)
  }
}

methods.sendActionNoResponse = async (packet) => {
  Redis.sendToList(packet.to,packet.protocol,packet.payload)
}

methods.redisSet = (key,value,expiry) => {
  return Redis.client.set(key,value,'EX', expiry)
}

methods.redisGet =  (key) => {
  return Redis.client.get(key)
}

methods.redisRemove =  (key) => {
  return Redis.client.del(key)
}

const healthCheck = async () =>{
  try {
    const sdkHealthCheckResponse = await healthCheckApp.healthCheck()
    if (!methods.healthCheck){
      return sdkHealthCheckResponse
    }

    const connectorHealthCheckResponse = await methods.healthCheck()
    return {...sdkHealthCheckResponse,...connectorHealthCheckResponse}
  }catch(err){
    throw err
  }
}


const getFlow = async (companyId,flowId) => {
  return flowsApp.getFlow(companyId,flowId)
}

const getFlowVersion = async (companyId,flowId,versionId) => {
  return flowVersionsDAO.getFlowVersion(flowId,companyId,versionId)
}

const updateFlow = async (companyId,flowId,props) => {
  return flowsDAO.updateFlow(companyId,flowId,props).then(k=>{
    k.companyId = k._id.companyId
    k.flowId = k._id.flowId
    delete k._id
    return k
  });
}

const logEvent = async (event) =>{
  if(!event.identity){
    event.identity = identity
  }
  event.capabilityName = 'add'
  if(!event.debugMode){
    delete event.properties
    delete event.parameters
    delete event.inputs
  }
  Redis.sendToList('eventsConnector', 'action', removeSensitiveInfo(event), null)
}

const httpServerListen = (identity, host,port) =>{
  return new Promise((resolve, reject) => {
    httpServer.listen(port, () => {
      console.log(`${identity} listening at http(s)://${host}:${port}`);
      resolve();
    });
  });
}

const sendToSlack = (channel, message) =>{
  return slack.sendToSlack(channel, message)
}

const stopReceivingEvents = () =>{
  logger.info(`Set flag to stop receiving events from redis`)
  Redis.stopReceivingEvents()
}

const startReceivingEvents = () =>{
  logger.info(`Set flag to start receiving events from redis`)
  Redis.startReceivingEvents()
}

const generateHash = () =>{
  return util.generateHash()
}

/**
 * Returns the first number from an array
 *
 * @param {number[]} numberList
 * @return {number|null}
 */
const getFirstNumberFromArray = (numberList = []) => {
  let result = null

  for (let i = 0; i < numberList.length; i++) {
    const value = numberList[i]

    if (typeof value === 'number') {
      result = value
      break
    }
  }

  return result
}

const initalize = async (listName,client,opts) => {
  identity = listName
  globalListName = listName
  if(!opts){
    opts = {}
  }

  opts.originalIdentity = listName

  if(typeof opts.resolveToFieldToConnector === 'boolean'){
    resolveToFieldToConnector = opts.resolveToFieldToConnector
  }

  if(typeof opts.handleCapability === 'boolean'){
    handleCapability = opts.handleCapability
  }

  if(typeof opts.logUserEvents === 'boolean'){
    logUserEvents = opts.logUserEvents
  }

  if(typeof opts.webServerMode === 'boolean'){
    webServerMode = opts.webServerMode
  }

  if(typeof opts.doNotUpdateCIProps === 'boolean'){
    doNotUpdateCIProps = opts.doNotUpdateCIProps
  }

  secretsClient = require('./modules/secrets');
  dbClient = require('./modules/db');

  connector = client
  try {
    const secretsResponse = await secretsClient.initialize()
    if(global.secrets && global.secrets.logLevel){
      console.log('Setting Log Level to ',global.secrets.logLevel)
      setLogLevel(global.secrets.logLevel)
    }
    if(opts.shard  === true){
      shard = true;
      const instanceKeyName = (global.secrets && global.secrets.appInstanceEnvKeyName)?global.secrets.appInstanceEnvKeyName:'NODE_APP_INSTANCE'
      globalListName = `${listName}_${process.env[instanceKeyName] != undefined?process.env[instanceKeyName]:0}`
//    globalListName = `${listName}_${os.hostname()}_${process.env.NODE_APP_INSTANCE != undefined?process.env.NODE_APP_INSTANCE:0}`
    }
    global.globalListName = globalListName


    const dbResponse = await dbClient.initialize()
    const redisclient = require('@skinternal/sk-redis')
    appsDAO = require('./data/appsDAO')
    eventsDAO = require('./data/eventsDAO')
    companyDAO = require('./data/companyDAO')
    flowsDAO = require('./data/flowsDAO')
    flowVersionsDAO = require('./data/flowVersionsDAO')
    usersDAO = require('./data/usersDAO')
    mdsDAO = require('./data/mdsDAO')
    devicesDAO = require('./data/devicesDAO')
    flowsApp = require('./apps/flowsApp')
    connectionsApp = require('./apps/connectionsApp')
    connectorsApp = require('./apps/connectorsApp')
    healthCheckApp = require('./apps/healthCheckApp')
    hashRing = require('./modules/hashRing')
    slack = require('./modules/slack')
    util = require('./modules/util')
    upload = require('./modules/upload');

    if(resolveToFieldToConnector) {
      try {
        const tmpConnectorInfo = await connectorsApp.getConnectorDetails(listName)
        if (!(tmpConnectorInfo && tmpConnectorInfo.connector)) {
          //throw "Connector Manifest not found"
        }
        connectorManifest = tmpConnectorInfo.connector
        let localizedErrors = {}
        if(connectorManifest && connectorManifest.capabilities){
          Object.keys(connectorManifest.capabilities).forEach(k=>{
            if(connectorManifest.capabilities[k].localizedErrors){
              localizedErrors = _.merge(localizedErrors,connectorManifest.capabilities[k].localizedErrors)
            }
          })
        }
        console.log('Localized Errors:::',localizedErrors)
        global.localizedErrors = localizedErrors
      } catch (err) {
        console.log("Not throw err")
        console.log(err)
      }
    }

    const throttledLog = (fn, wait = 2000, trailing = false) => _.throttle((...args) => fn(...args), wait, {
      trailing
    });

    const connectorConfigs = _.get(global, 'secrets.connectorConfigs', {listName:{}});

    const currentConfig = connectorConfigs[listName];

    if (currentConfig) {
      const memoryThreshold = _.get(currentConfig, 'memoryThreshold', {});
      logger.debug('memoryThresholdFromSecrets', {memoryThreshold});

      const memoryThresholdLogThrottle = memoryThreshold.logThrottle;

      const log = throttledLog(logger.info, memoryThresholdLogThrottle);

      if (memoryThreshold && memoryThreshold.enabled) {
        const interval = memoryThreshold.interval || 2000;
        const maxMemoryThreshold = memoryThreshold.maxThreshold;
        const minMemoryThreshold = memoryThreshold.minThreshold;

        setInterval(() => memory.monitorHeap({
          maxMemoryThreshold: maxMemoryThreshold,
          minMemoryThreshold: minMemoryThreshold,
          onThresholdReached: stopReceivingEvents,
          onMemoryFreed: startReceivingEvents,
          log
        }), interval);
      }

      const rateLimit = _.get(currentConfig, 'connectorRateLimit', {});
      logger.debug('rateLimitFromSecrets',{rateLimit})

      queueOpts.limit = getFirstNumberFromArray([rateLimit.limit, opts.queueLimit, queueOpts.limit]);
      queueOpts.delay = getFirstNumberFromArray([rateLimit.delay, opts.queueDelay, queueOpts.delay]);
      queueOpts.concurrency = getFirstNumberFromArray([rateLimit.concurrency, opts.queueConcurrency, queueOpts.concurrency]);

      if (typeof rateLimit.queuePacket ==='boolean'?rateLimit.queuePacket:opts.queuePacket) {
        queueOpts.enabled = true;

        packetQueue = async.cargoQueue(async (tasks, queueCallback) => {
          for (let i = 0; i < tasks.length; i++) {
            let task = tasks[i];
            await processPacket(task.packet, task.callback, task.httpCallback)

          }
          queueCallback();
        }, queueOpts.concurrency, queueOpts.limit);
      }
    }

    Redis = new redisclient({ identity: globalListName ,...opts, receiveEventsFlag:typeof opts.receiveEventsFlag !== 'boolean'?false:opts.receiveEventsFlag,queuePacket: !!queueOpts.enabled,queueConcurrency:queueOpts.concurrency})
    global.Redis = Redis;
    Redis.on('message', queueProcessPacket);
    redisDAO = require('./data/redisDAO')

    Redis.on('command', processCommand);


    if(global.secrets.msInstances){
      hashRing.initialize(global.secrets.msInstances)
    }

    if(webServerMode) {
      globalRoute = require('./routes/globalRoute')
      express = require('express')
      router = express.Router(),
          app = express()
      bodyParser = require('body-parser')
      app.use(bodyParser.json({limit: '5mb'}));
      router.use('/', globalRoute);
      app.use('/', router);
      if(opts.httpsEnabled){
        console.log('Havent implemented https yet')
      } else {

        httpServer = require('http').Server(app);
      }
      const listenResponse = await httpServerListen(identity,'localhost',process.env.SK_CONNECTOR_WEBSERVER_PORT?process.env.SK_CONNECTOR_WEBSERVER_PORT:global.secrets && global.secrets.connector && global.secrets.connector.port?global.secrets.connector.port:3000)
    }


    logger.info('final queueOpts',{queueOpts})
    logger.info(`Successfully Started SkConnector SDK Version: ${version}`)

    //If the connector microserivce has not defined the receiveEventsFlag or has defined it as true, then startReceiving events
    // Note a microservice - OE for example, sets this flag as false, so that it can control when to start receiving events.
    if(typeof opts.receiveEventsFlag !== 'boolean' || opts.receiveEventsFlag === true){
      startReceivingEvents()
    }
    return {success:true,message:"Initialization Succeeded",listName,globalListName}
  }catch(err){
    throw err
  }
}

const createCredential = async params => {
  return usersDAO.createCredential(params);
}

const deleteCredential = async params => {
  return usersDAO.deleteCredential(params);
}

const updateCredential = async params => {
  return usersDAO.updateCredential(params);
}

const getUserRecoveryCodes = (userId,companyId) => {
  return usersDAO.getUserRecoveryCodes(userId,companyId);
}

const uploadFile = (file, data, type) => {
  return upload.uploadFile(file, data, type);
}

process.on('SIGINT', async function(msg) {
  // If service is blacklisted, return without additional operation
  // The service itself will be responsible for handling exit
  if (PROCESS_EXIT_BLACKLIST.includes(identity)) {
    logger.info(`${globalListName} should handle process exit.`)
    return;
  }

  logger.debug(`${globalListName} SIGINT Received!`);

  try {
    stopReceivingEvents();

    logger.debug(`${globalListName} Stopped!`);
    setTimeout(() => process.exit(0), 2000);
  }catch(err){
    logger.error('Error: SIGINT', err);
    process.exit(0);
  }
});

module.exports = {
  uuidv4,
  randomBase64URLBuffer,
  storeChallengeDB,
  getChallengeDB,
  updateChallengeStatusDB,
  getUserByUserId,
  getCompany,
  getFlow,
  getFlowVersion,
  updateFlow,
  mdsDAO_getAll,
  mdsDAO_updatePayload,
  mdsDAO_createRecord,
  devicesDAO_getDevice,
  usersDAO_incrementVariable,
  usersDAO_saveVariable,
  usersDAO_saveVariables,
  startSessionRedisOpenIdCode,
  initalize,
  methods,
  redisSendSync,
  redisPublish,
  redisPublishCommand,
  logEvent,
  appsDAO_getApp,
  logger,
  compileErr,
  serr,
  sendToSlack,
  healthCheck,
  stopReceivingEvents,
  startReceivingEvents,
  generateHash,
  redisDAO_updateInteractionVariables,
  redisDAO_incrementInteractionVariable,
  createCredential,
  deleteCredential,
  updateCredential,
  usersDAO_getUserByConnectionIdEmail,
  usersDAO_getUser,
  usersDAO_updateUser,
  getConnectionDetails,
  usersDAO_getUserByAlias,
  getUserRecoveryCodes,
  uploadFile,
  processPacket
}
